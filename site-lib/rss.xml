<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Sheibah]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Sheibah</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sat, 22 Nov 2025 16:32:38 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sat, 22 Nov 2025 16:32:37 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[خوش آمدید]]></title><description><![CDATA[<a data-href="تبدیل ابسیدین به بیربلاگ" href="تبدیل-ابسیدین-به-بیربلاگ.html" class="internal-link" target="_self" rel="noopener nofollow">تبدیل ابسیدین به بیربلاگ</a><br>
<a data-href="تبدیل متن اشتباه با کیبورد مغایر" href="تبدیل-متن-اشتباه-با-کیبورد-مغایر.html" class="internal-link" target="_self" rel="noopener nofollow">تبدیل متن اشتباه با کیبورد مغایر</a><br>
<a data-href="تقسیم فایل صوتی" href="تقسیم-فایل-صوتی.html" class="internal-link" target="_self" rel="noopener nofollow">تقسیم فایل صوتی</a><br>
<a data-href="تغییر اندازه فایلهای ورد" href="تغییر-اندازه-فایلهای-ورد.html" class="internal-link" target="_self" rel="noopener nofollow">تغییر اندازه فایلهای ورد</a>]]></description><link>خوش-آمدید.html</link><guid isPermaLink="false">Other/کدها/خوش آمدید.md</guid><pubDate>Sat, 22 Nov 2025 16:32:23 GMT</pubDate></item><item><title><![CDATA[تبدیل متن اشتباه با کیبورد مغایر]]></title><description><![CDATA[اگر متن فارسی را به اشتباه با کیبورد انگلیسی تایپ کردید یا بر عکس از این کد استفاده کنید:
متن اشتباه تایپ‌شده را کپی کنید (Ctrl+C).
اگر پایتون ندارید، فایل FaultyKeyboard.exe را از <a data-tooltip-position="top" aria-label="https://eitaa.com/shei_bah/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://eitaa.com/shei_bah/191" target="_self">اینجا</a> دانلود و اجرا کنید (با دوبار کلیک یا از طریق Command Prompt). / اگر پایتون دارید، <a data-href="#متن کد" href="تبدیل-متن-اشتباه-با-کیبورد-مغایر.html#متن_کد_0" class="internal-link" target="_self" rel="noopener nofollow">متن کد</a> را داخل یک فایل متنی با فرمت .py ذخیر کنید و سپس اجرا کنید.
متن اصلاح‌شده به‌صورت خودکار در کلیپ‌بورد قرار می‌گیرد.
آن را هرجا خواستید Paste کنید (Ctrl+V).
# -*- coding: utf-8 -*-
"""
Bidirectional Persian–English keyboard remapper using clipboard.
- Automatically detects layout direction.
- Reads input from clipboard.
- Writes remapped output back to clipboard.
""" import pyperclip PERSIAN_TO_EN = { 'ض': 'q', 'ص': 'w', 'ث': 'e', 'ق': 'r', 'ف': 't', 'غ': 'y', 'ع': 'u', 'ه': 'i', 'خ': 'o', 'ح': 'p', 'ج': '[', 'چ': ']', 'ش': 'a', 'س': 's', 'ی': 'd', 'ب': 'f', 'ل': 'g', 'ا': 'h', 'ت': 'j', 'ن': 'k', 'م': 'l', 'ک': ';', 'گ': "'", 'ظ': 'z', 'ط': 'x', 'ز': 'c', 'ر': 'v', 'ذ': 'b', 'د': 'n', 'پ': 'm', '،': ',', '؛': ';', '؟': '?', '‌': ' ', 'ٔ': '', '‍': '', 'ـ': '-', '۰': '0', '۱': '1', '۲': '2', '۳': '3', '۴': '4', '۵': '5', '۶': '6', '۷': '7', '۸': '8', '۹': '9',
} EN_TO_PERSIAN = { 'q': 'ض', 'w': 'ص', 'e': 'ث', 'r': 'ق', 't': 'ف', 'y': 'غ', 'u': 'ع', 'i': 'ه', 'o': 'خ', 'p': 'ح', '[': 'ج', ']': 'چ', 'a': 'ش', 's': 'س', 'd': 'ی', 'f': 'ب', 'g': 'ل', 'h': 'ا', 'j': 'ت', 'k': 'ن', 'l': 'م', ';': 'ک', "'": 'گ', 'z': 'ظ', 'x': 'ط', 'c': 'ز', 'v': 'ر', 'b': 'ذ', 'n': 'د', 'm': 'پ', ',': '،', '?': '؟', '0': '۰', '1': '۱', '2': '۲', '3': '۳', '4': '۴', '5': '۵', '6': '۶', '7': '۷', '8': '۸', '9': '۹',
} SPACE_TO_PERSIAN = ' ' # or '\u200c' for ZWNJ def remap_text(text: str, direction: str = 'auto') -&gt; str: has_persian = any(ch in PERSIAN_TO_EN for ch in text) if direction == 'auto': direction = 'fa2en' if has_persian else 'en2fa' if direction == 'fa2en': mapping = PERSIAN_TO_EN def map_char(ch): return mapping.get(ch, ch) else: mapping = EN_TO_PERSIAN def map_char(ch): if ch == ' ': return SPACE_TO_PERSIAN return mapping.get(ch.lower(), ch) return ''.join(map_char(ch) for ch in text) # ---- Clipboard Integration ----
if __name__ == '__main__': input_text = pyperclip.paste() output_text = remap_text(input_text) pyperclip.copy(output_text) print("✅ Remapped text copied to clipboard.")
]]></description><link>تبدیل-متن-اشتباه-با-کیبورد-مغایر.html</link><guid isPermaLink="false">Other/کدها/تبدیل متن اشتباه با کیبورد مغایر.md</guid><pubDate>Sun, 28 Sep 2025 21:22:51 GMT</pubDate></item><item><title><![CDATA[تقسیم فایل صوتی]]></title><description><![CDATA[
پایتون را نصب کنید.
بااستفاده از این کد در cmd، اجزای مورد نیاز را نصب کنید:
pip install ffmpeg-python با استفاده از <a data-href="راهنمای نصب افزونه ffmpeg" href="other/راهنما/راهنمای-نصب-افزونه-ffmpeg.html" class="internal-link" target="_self" rel="noopener nofollow">راهنمای نصب افزونه ffmpeg</a> آن را نصب کنید.
<br><a data-href="#کد" href="تقسیم-فایل-صوتی.html#کد_0" class="internal-link" target="_self" rel="noopener nofollow">کد</a> پایین صفحه را در فایل متنی قرار داده و با فرمت .py ذخیره کنید.
کد را اجرا کنید.
قطعات تقسیم شده در پوشه chunks ذخیره می شود.
import ffmpeg
import os # Get current folder
script_dir = os.path.dirname(os.path.abspath(__file__)) # Find the first .mp3 file in the folder
audio_file = None
for filename in os.listdir(script_dir): if filename.lower().endswith(".mp3"): audio_file = filename break if not audio_file: print("No .mp3 file found in this folder.") exit() input_path = os.path.join(script_dir, audio_file)
base_name = os.path.splitext(audio_file)[0] # Create output folder
output_folder = os.path.join(script_dir, "chunks")
os.makedirs(output_folder, exist_ok=True) # Get duration in seconds
probe = ffmpeg.probe(input_path)
duration = float(probe['format']['duration']) # Split into 5-minute chunks
chunk_length = 300 # seconds
for i in range(0, int(duration), chunk_length): output_path = os.path.join(output_folder, f"{base_name}_part{i//chunk_length + 1}.mp3") ffmpeg.input(input_path, ss=i, t=chunk_length).output(output_path).run() print(f"Exported: {output_path}")
]]></description><link>تقسیم-فایل-صوتی.html</link><guid isPermaLink="false">Other/کدها/تقسیم فایل صوتی.md</guid><pubDate>Fri, 26 Sep 2025 07:52:28 GMT</pubDate></item><item><title><![CDATA[تغییر اندازه فایلهای ورد]]></title><description><![CDATA[با این کد می توانید با یک کلیک، اندازه صفحه فایلهای ورد، میزان حاشیه آنها و اندازه فونت پاورقی را تغییر دهید.
اندازه پیش فرض 11cm در 23cm است و میزان حاشیه های پیش فرض از بالا و پایین 1 و از طرفین 0.6 است.
اندازه فونت پاورقی پیش فرض نیز 7 می باشد.
برای تغییر اندازه های پیش فرض، درون کد، به بخش def process_document بروید.
پایتون رو نصب کنید.
از طریق کد زیر در cmd افزونه مورد نیاز رو نصب کنید:
pip install pywin32 کد (یاکد اصلاح شده) را از پایین همین صفحه بردارید، در یک فایل متنی قرار دهید و آن را با پسوند .py ذخیره کنید.
یک پوشه در کنار فایل کد پایتون به نام mabda و یک پوشه به نام maqsad بسازید. (اگر کد اصلاح شده را بردارید نیاز به این پوشه ها نیست.)
فایل های ورد .docx مورد نظر خود را داخل پوشه mabda قرار دهید.
کد پایتون را اجرا کنید.
فایل های ورود و پی دی اف خروجی را از داخل پوشه مقصد بردارید.
import win32com.client as win32
import os
import traceback # Built-in style IDs (language-independent)
WD_STYLE_FOOTNOTE_TEXT = -5
WD_STYLE_FOOTNOTE_REFERENCE = -6 def cm_to_pt(cm): return cm * 28.35 def apply_page_setup_to_all_sections(doc, width_cm, height_cm, margin_left, margin_right, margin_top, margin_bottom): for sec in doc.Sections: ps = sec.PageSetup ps.PageWidth = cm_to_pt(width_cm) ps.PageHeight = cm_to_pt(height_cm) ps.LeftMargin = cm_to_pt(margin_left) ps.RightMargin = cm_to_pt(margin_right) ps.TopMargin = cm_to_pt(margin_top) ps.BottomMargin = cm_to_pt(margin_bottom) def set_footnote_styles(doc, size_pt): try: # Use built-in style IDs to avoid localization issues st = doc.Styles(WD_STYLE_FOOTNOTE_TEXT).Font st.Size = size_pt # For Persian/Arabic (complex script) font size try: st.SizeBi = size_pt except Exception: pass sr = doc.Styles(WD_STYLE_FOOTNOTE_REFERENCE).Font sr.Size = size_pt try: sr.SizeBi = size_pt except Exception: pass except Exception as e: print("! Could not adjust footnote styles:", e) def force_apply_footnote_size(doc, size_pt): # Some documents have direct formatting that overrides style; # clear it and reapply size, including SizeBi for RTL scripts. for fn in doc.Footnotes: rng = fn.Range # Clear direct character formatting (method availability varies by version) cleared = False try: # Best method (Word 2010+) rng.ClearCharacterDirectFormatting() cleared = True except Exception: try: # Fallback rng.Font.Reset() cleared = True except Exception: pass # Apply size (normal + complex script) try: rng.Font.Size = size_pt except Exception: pass try: rng.Font.SizeBi = size_pt except Exception: pass def process_document(word, in_path, out_docx, out_pdf, width_cm=11, height_cm=23, margin_left=1, margin_right=1, margin_top=0.6, margin_bottom=0.6, footnote_font_size=7): # Open doc = word.Documents.Open(in_path) # Page setup across all sections apply_page_setup_to_all_sections( doc, width_cm, height_cm, margin_left, margin_right, margin_top, margin_bottom ) # Footnotes: set styles + force apply on existing ranges set_footnote_styles(doc, footnote_font_size) force_apply_footnote_size(doc, footnote_font_size) # Save DOCX doc.SaveAs(out_docx) # Save PDF (17 = wdFormatPDF) doc.SaveAs(out_pdf, FileFormat=17) # Close doc.Close(False) def main(): base_dir = os.path.dirname(os.path.abspath(__file__)) input_folder = os.path.join(base_dir, "mabda") output_folder = os.path.join(base_dir, "maqsad") os.makedirs(output_folder, exist_ok=True) files = [f for f in os.listdir(input_folder) if f.lower().endswith(".docx")] total = len(files) if total == 0: print("No .docx files found in 'mabda'.") return # Start Word once word = win32.gencache.EnsureDispatch('Word.Application') word.Visible = False try: for idx, filename in enumerate(files, start=1): in_path = os.path.join(input_folder, filename) name, _ = os.path.splitext(filename) out_docx = os.path.join(output_folder, f"{name}_mobile.docx") out_pdf = os.path.join(output_folder, f"{name}_mobile.pdf") print(f"[{idx}/{total}] Processing: {filename}") try: process_document(word, in_path, out_docx, out_pdf) except Exception as doc_err: print(f"! Failed on {filename}: {doc_err}") traceback.print_exc() finally: # Quit Word even if something goes wrong word.Quit() print("✅ All files processed. Check the 'maqsad' folder.") if __name__ == "__main__": main()
در این کد، دیگر نیاز به پوشه مبدا و مقصد نیست.
فایل اصلی در کنار فایل کد .py قرار داده می شود، و خروجی هم کنار آن قرار می گیرد.import win32com.client as win32
import os
import traceback # Built-in style IDs (language-independent)
WD_STYLE_FOOTNOTE_TEXT = -5
WD_STYLE_FOOTNOTE_REFERENCE = -6 def cm_to_pt(cm): return cm * 28.35 def apply_page_setup_to_all_sections(doc, width_cm, height_cm, margin_left, margin_right, margin_top, margin_bottom): for sec in doc.Sections: ps = sec.PageSetup ps.PageWidth = cm_to_pt(width_cm) ps.PageHeight = cm_to_pt(height_cm) ps.LeftMargin = cm_to_pt(margin_left) ps.RightMargin = cm_to_pt(margin_right) ps.TopMargin = cm_to_pt(margin_top) ps.BottomMargin = cm_to_pt(margin_bottom) def set_footnote_styles(doc, size_pt): try: # Use built-in style IDs to avoid localization issues st = doc.Styles(WD_STYLE_FOOTNOTE_TEXT).Font st.Size = size_pt # For Persian/Arabic (complex script) font size try: st.SizeBi = size_pt except Exception: pass sr = doc.Styles(WD_STYLE_FOOTNOTE_REFERENCE).Font sr.Size = size_pt try: sr.SizeBi = size_pt except Exception: pass except Exception as e: print("! Could not adjust footnote styles:", e) def force_apply_footnote_size(doc, size_pt): # Some documents have direct formatting that overrides style; # clear it and reapply size, including SizeBi for RTL scripts. for fn in doc.Footnotes: rng = fn.Range # Clear direct character formatting (method availability varies by version) cleared = False try: # Best method (Word 2010+) rng.ClearCharacterDirectFormatting() cleared = True except Exception: try: # Fallback rng.Font.Reset() cleared = True except Exception: pass # Apply size (normal + complex script) try: rng.Font.Size = size_pt except Exception: pass try: rng.Font.SizeBi = size_pt except Exception: pass def process_document(word, in_path, out_docx, out_pdf, width_cm=11, height_cm=23, margin_left=0.5, margin_right=0.5, margin_top=0.6, margin_bottom=0.6, footnote_font_size=7): # Open doc = word.Documents.Open(in_path) # Page setup across all sections apply_page_setup_to_all_sections( doc, width_cm, height_cm, margin_left, margin_right, margin_top, margin_bottom ) # Footnotes: set styles + force apply on existing ranges set_footnote_styles(doc, footnote_font_size) force_apply_footnote_size(doc, footnote_font_size) # Save DOCX doc.SaveAs(out_docx) # Save PDF (17 = wdFormatPDF) doc.SaveAs(out_pdf, FileFormat=17) # Close doc.Close(False) def main(): base_dir = os.path.dirname(os.path.abspath(__file__)) input_folder = os.path.join(base_dir) output_folder = os.path.join(base_dir) files = [f for f in os.listdir(input_folder) if f.lower().endswith(".docx")] total = len(files) if total == 0: print("No .docx files found in 'mabda'.") return # Start Word once word = win32.gencache.EnsureDispatch('Word.Application') word.Visible = False try: for idx, filename in enumerate(files, start=1): in_path = os.path.join(input_folder, filename) name, _ = os.path.splitext(filename) out_docx = os.path.join(output_folder, f"{name}_mobile.docx") out_pdf = os.path.join(output_folder, f"{name}_mobile.pdf") print(f"[{idx}/{total}] Processing: {filename}") try: process_document(word, in_path, out_docx, out_pdf) except Exception as doc_err: print(f"! Failed on {filename}: {doc_err}") traceback.print_exc() finally: # Quit Word even if something goes wrong word.Quit() print("✅ All files processed.") if __name__ == "__main__": main()
]]></description><link>تغییر-اندازه-فایلهای-ورد.html</link><guid isPermaLink="false">Other/کدها/تغییر اندازه فایلهای ورد.md</guid><pubDate>Thu, 25 Sep 2025 19:46:20 GMT</pubDate></item><item><title><![CDATA[تبدیل ابسیدین به بیربلاگ]]></title><description><![CDATA[
پایتون رو نصب کن.
پایپرکلیپ رو به این صورت نصب کن: توی ویندوز cmd یا powershell رو باز کن.
این کد رو اونجا کپی و اجرا کن: pip install pyperclip حالا سیستم شما آماده است: متن نوت ابسیدین رو کپی کن.
فایل generate_toc_clipboard.py رو اجرا کن. generate_toc_clipboard.py
حالا وارد <a data-tooltip-position="top" aria-label="https://bearblog.dev" rel="noopener nofollow" class="external-link is-unresolved" href="https://bearblog.dev" target="_self">بیربلاگ</a> شو و متنت رو پیست کن. import re
import html
import pyperclip # pip install pyperclip HEADING_RE = re.compile(r"^(#{1,6})\s+(.+)$", flags=re.MULTILINE) def slugify(text: str) -&gt; str: t = text.strip().lower() t = re.sub(r"[^\w\s\-\u0600-\u06FF]", "", t) t = re.sub(r"\s+", "-", t) return t def extract_headings(md: str): items = [] for m in HEADING_RE.finditer(md): hashes, title = m.group(1), m.group(2).strip() level = len(hashes) slug = slugify(title) items.append({"level": level, "text": title, "slug": slug, "start": m.start()}) return items def insert_anchors(md: str, headings): out = md for h in reversed(headings): anchor = f'&lt;a id="{h["slug"]}"&gt;&lt;/a&gt;\n' out = out[:h["start"]] + anchor + out[h["start"]:] return out def build_toc(headings, min_level=2): filtered = [h for h in headings if h["level"] &gt;= min_level] if not filtered: return "" lines = ['&lt;nav class="toc"&gt;', "&lt;ul&gt;"] base = min(h["level"] for h in filtered) prev = base for h in filtered: lvl = h["level"] while prev &lt; lvl: lines.append("&lt;ul&gt;") prev += 1 while prev &gt; lvl: lines.append("&lt;/ul&gt;") prev -= 1 text = html.escape(h["text"]) lines.append(f'&lt;li&gt;&lt;a href="#{h["slug"]}"&gt;{text}&lt;/a&gt;&lt;/li&gt;') while prev &gt; base: lines.append("&lt;/ul&gt;") prev -= 1 lines.extend(["&lt;/ul&gt;", "&lt;/nav&gt;", ""]) return "\n".join(lines) def normalize_paragraph_spacing(md: str) -&gt; str: lines = md.splitlines() output = [] in_code_block = False for i, line in enumerate(lines): stripped = line.strip() if stripped.startswith("```"): in_code_block = not in_code_block output.append(line) continue output.append(line) if in_code_block: continue if i &lt; len(lines) - 1: next_line = lines[i + 1].strip() if ( stripped and next_line and not next_line.startswith(("#", "-", "*", "&gt;")) and not stripped.endswith(" ") ): output.append("") # extra blank line return "\n".join(output) def main(include_h1=False): # 1. Get text from clipboard md = pyperclip.paste() # 2. Fix paragraph spacing md = normalize_paragraph_spacing(md) # 3. Extract headings and build TOC headings = extract_headings(md) if not headings: pyperclip.copy(md) print("No headings found. Copied original content back to clipboard.") return toc = build_toc(headings, min_level=1 if include_h1 else 2) md_with_anchors = insert_anchors(md, headings) result = (toc + "\n" + md_with_anchors).lstrip() # 4. Copy result back to clipboard pyperclip.copy(result) print(f"Processed content copied to clipboard with {len([h for h in headings if (h['level']&gt;=2 or include_h1)])} TOC items.") if __name__ == "__main__": main(include_h1=False) # Change to True if you want H1 in TOC ]]></description><link>تبدیل-ابسیدین-به-بیربلاگ.html</link><guid isPermaLink="false">Other/کدها/تبدیل ابسیدین به بیربلاگ.md</guid><pubDate>Sun, 21 Sep 2025 20:18:25 GMT</pubDate></item></channel></rss>